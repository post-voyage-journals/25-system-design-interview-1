## 상용 드라이브 서비스들

- **구글 드라이브**
- **드롭박스**
- **마이크로소프트 원드라이브**
- **애플 아이클라우드**
- **Box**
- **Amazon Drive**
- **네이버 MYBOX**

## 설계 요구사항

기능적 요구사항

- 구현 기능들
  - 파일 업로드
  - 파일 다운로드
  - 여러 단말 간 파일 동기화
  - 파일 갱신 이력 동기화
  - 파일 공유
  - 알림 (파일 편집 및 삭제 시)
- 웹 및 모바일 앱 지원
- 파일 암호화 포함
- 파일 크기 10GB 제한
- 가입 사용자 5천만(50million), DAU 1천만(10million)
  - 매일 각 사용자가 평균 2개 파일을 업로드한다고 가정
  - 각 파일의 평균 크기는 500KB로 가정
  - 필요한 저장공간 총량 = 500PB
  - 업로드 API QPS = 240 ~ 480
- 모든 사용자들에게 10GB 무료 저장공간 제공

비기능적 요구사항

- 데이터 손실이 발생하지 않는 안정성
- 빠른 동기화 속도
- 모바일 환경에서도 사용할 만한 네트워크 대역폭
- 대용량 트래픽을 처리할 수 있는 규모 확장성
- 고가용성

## API

- 사용자 인증 필요
- HTTPS 프로토콜을 사용해야 함

### 파일 업로드 API

- 2가지 종류의 업로드 지원
  - 파일 크기가 적을 때의 단순 업로드
  - 파일 크기가 클 때의 resumable 업로드
- 인자
  - `uploadType` : simple / resumable
  - `data` : 업로드할 파일
- 이어 올리기 단계
  - 이어 올리기 URL을 받기 위한 최초 요청 전송
  - 데이터 업로드 및 업로드 상태 모니터링
  - 만약 장애가 발생하면 해당 지점부터 다시 업로드

### 파일 다운로드 API

- 인자
  - `path` : 다운로드할 파일의 경로

### 파일 갱신 히스토리 API

- 인자
  - `path` : 갱신 히스토리를 조회할 파일의 경로
  - `limit` : 조회할 히스토리 최대 길이

## AWS S3 활용 방안

- 여러 리전에 걸쳐서 다중화 가능
  - 데이터 손실을 막고 고가용성 보장
- 파일 시스템과도 같은 폴더 구조
- 추가적으로 메타데이터 DB를 활용해 SPOF 문제 회피

## 동기화 충돌

- 여러 사용자가 동시에 업데이트할 때의 충돌을 해소해야 함
- 버전 충돌에 대한 대안도 마련할 것

## 컴포넌트

### 사용자 단말

- 웹 브라우저, 모바일 앱 등의 클라이언트

### block 서버

- 파일 블록을 클라우드 저장소에 업로드하는 서버
- "block-level storage" 라고도 불림
- 파일을 여러 개의 블록으로 나눠서 저장하는 역할 수행
  - 각 블록에는 고유한 해시값이 할당됨
  - 해시값은 메타데이터 DB에 저장
  - 파일 재구성 시 블록들을 원래 순서대로 합쳐야 함
- 네트워크 대역폭 최적화 방법
  - delta sync
    - 파일 수정 시 파일 전체가 아닌 수정된 블록만 동기화
    - 수정 후 수정된 블록들만 다시 클라우드 저장소로 업로드
  - 압축
    - 블록 단위로 압축
    - 압축 알고리즘은 파일 유형에 따라 정함
- 동작 순서
  - 파일을 작은 블록들로 분할
  - 각 블록 압축
  - 각 블록 암호화
  - 클라우드 저장소로 업로드

### 클라우드 저장소

- 블록 단위로 나눠진 파일은 S3 등의 클라우드 저장소에 보관됨

### cold storage

- 오랫동안 사용되지 않은 비활성 데이터 저장소

### 로드밸런서

- 요청을 모든 API 서버에 고르게 분산

### API 서버

- 파일 업로드 외 대부분의 기능들 수행
- 사용자 인증, 사용자 프로필 관리, 파일 메타데이터 갱신 등

### 메타데이터 DB

- 사용자, 파일, 블록, 버전 등 메타데이터 정보 관리

### 메타데이터 캐시

- 자주 쓰이는 메타데이터 캐시

### 알림 서비스

- pub/sub 기반
- 파일 추가, 편집, 삭제 알림
- 파일 최신 상태 확인 용도

### offline backup queue

- 클라이언트가 미접속 상태인 경우 파일 갱신을 접속 후 동기화할 수 있도록 큐에 담아둠

## 업로드 절차

- 파일 메타데이터 추가
  - 클라이언트의 메타데이터 추가 요청 전송
  - 메타데이터를 DB에 저장하고, 업로드 상태를 pending 으로 변경
  - 새 파일 추가 진행 중 알림 전송
- 파일 업로드
  - 파일을 블록 저장소 서버에 업로드
  - 블록 저장소 서버는 파일을 분할 → 압축 → 암호화 → 클라우드 전송
  - 업로드 완료 시 클라우드 스토리지는 완료 콜백 전송
  - 메타데이터 DB는 콜백을 받고 파일 상태를 pending → uploaded 로 변경
  - 파일 업로드 완료 알림 전송

## 다운로드 절차

- 파일 추가 및 편집 시 자동 진행
- 파일 변경 감지를 위해 2가지 방법 사용
  - 접속 중일 때 파일이 변경된 경우, 새 버전을 다운로드 받으라고 알림 전송
  - 미접속 중일 때 파일이 변경된 경우, 캐시에 보관 후 접속했을 때 전송 (큐?)

다운로드 순서

1. 알림 서비스가 파일 변경을 알림
2. 알림을 확인한 클라이언트는 새로운 메타데이터 요청
3. API 서버는 메타데이터 DB로부터 새로운 메타데이터 조회
4. 클라이언트는 메타데이터를 받는 즉시 블록 다운로드 요청 전송
5. 블록 저장소 서버는 클라우드 저장소로부터 블록 다운로드
6. 클라이언트는 반환된 블록들을 갖고 파일 재구성

## 알림 서비스

- 파일 충돌을 줄이기 위해, 로컬에서의 파일 수정 상황을 다른 클라이언트들에게도 알려야 함
- 롱 폴링 방식
  - 롱 폴링, 웹소켓 등 2개 정도의 선택지가 있는데, 양방향 통신이 필요 없고, 실시간 통신의 필요성도 적으므로 **롱 폴링**이 적합
  - 각 클라이언트는 알림 서버와 롱 폴링 연결을 유지하다가 특정 파일 변경을 감지하면 연결 해제
  - 변경 감지로 인한 연결 해제 시 클라이언트는 반드시 메타데이터 최신 내역을 다운로드할 것
  - 연결 타임아웃 시 즉시 연결을 복원하고 유지해야 함

## 저장소 공간 절약 방식

- 중복 제거
  - 해시값을 기반으로 중복 파일을 비교한 뒤 삭제
- 지능적 백업 전략
  - 파일 버전 개수 상한 설정
  - 중요 버전만 보관
- cold storage 활용
  - 자주 사용되지 않는 데이터는 아카이빙 저장소로 옮기기
  - S3 Glacier가 적합

## 장애 처리

- 로드밸런서 장애
  - Secondary 로드밸런서 활성화 후 트래픽 옮기기
  - heartbeat 신호를 주기적으로 보내면서 모니터링
- 블록 저장소 서버 장애
  - 다른 서버거 미처리된 작업들을 이어받아야 함
- 클라우드 저장소 장애
  - S3 버킷 다중화 활용
- API 서버 장애
  - 장애 서버를 격리하고 트래픽 전송 X
- 메타데이터 캐시 장애
  - 캐시 서버 다중화 활용
- 메타데이터 DB 장애
  - 메인 DB 장애 시 복제본 중 하나를 메인으로 승격하고, 복제본 추가
  - 복제본 DB 장애 시 다른 복제본으로 요청을 전송하고 복제본 교체
- 알림 서비스 장애
  - 접속 중인 모든 사용자는 알림 서버와 롱 폴링 연결을 유지해야 함
  - 롱 폴링 유지는 쉽지만 개설은 상대적으로 느리다는 점 명심
- 오프라인 사용자 백업 큐 장애
  - 다중화 방식 활용
  - 구독 중이었던 클라이언트들의 구독 관계 재설정

## 추가 고려사항들

- 블록 저장소 서버 없이, 클라이언트에서 클라우드 저장소로 직접 업로드한다면?
  - 클라이언트에 분할, 압축, 암호화 로직을 두어야 함
  - iOS, 안드로이드, 웹 등 플랫폼 별로 로직을 구현할 것
  - 다만 클라이언트 해킹 가능성 때문에 위험할 수 있음
- 접속 상태 관리 서비스를 별도로 구성하기
  - 알림 서비스와 함께 책임과 역할 구분
