## 설계 요구사항

- 비 관계형(non-relational) 데이터베이스
- Key
  - 고유 식별자(identifier)로서 유일할 것
  - 일반 텍스트일 수도, 해시 값일 수도 있지만 가급적 짧아야 함
- Value
  - 문자열일 수도, 리스트일 수도, 객체일 수도 있음
- Key-Value 쌍의 크기는 10KB 이하
- 큰 데이터를 저장할 수 있을 것
- 고가용성 제공 (장애가 발생해도 빠른 응답속도 유지)
- 높은 규모의 확장성 제공 (트래픽 양에 따라 자동으로 서버 증설 및 삭제)
- 데이터 일관성 수준을 조절할 수 있어야 함
- 짧은 지연 시간을 유지해야 함

## 단일 서버로 구현할 경우

- 가장 쉽고 빠른 방법은 메모리에 해시 테이블로 저장하는 것
- 하지만 큰 데이터를 전부 메모리에 두는 것은 불가능

개선책

- 데이터 압축(compression)
- 사용 빈도에 따라 높으면 메모리에, 낮으면 디스크에 저장

⇒ 단일 서버로는 한계가 존재하며, 많은 데이터 저장을 위해서는 분산형으로 구현해야 함

## 분산 키-값 저장소 구현

### CAP

- **Consistency(일관성)**: 어떤 노드에 접속해도 항상 같은 데이터를 조회할 것
- **Availability(가용성)**: 일부 노드에 장애가 발생해도 항상 응답을 받을 수 있을 것
- **Partition tolerance(파티션 내구성)**: 두 노드 사이에 통신 장애가 발생해도 시스템이 유지될 것

### 핵심 문제

- 분산 시스템은 파티션 문제를 피할 수 없으며, 파티션 문제 발생 시 일관성과 가용성 중 하나를 택해야 함
- 일관성을 택한 경우: 재분배 작업을 위해 쓰기 작업을 멈춰야 하므로 가용성이 깨짐
- 가용성을 택한 경우: 파티션 문제가 해결될 때까지 오래된 데이터를 반환하게 됨

### 데이터 파티션 나누기

- 분산 환경에서는 데이터를 어떻게 파티션 단위로 분할할지가 중요
- 어떻게 고르게 분산할 것인가? 노드 추가 및 삭제 시 어떻게 데이터 이동을 최소화할 것인가?
- **안정 해시(consistent hash)** 는 이 문제를 해결하기에 적합

### 데이터 다중화

- 동일한 데이터를 N개의 서버에 비동기적으로 다중화(replication)해서 가용성 및 안정성 확보
- 다만 가상 노드도 사용할 경우에는 동일한 물리 서버를 중복으로 선택하지 않도록 유의해야 함

### 데이터 일관성

- 여러 노드에 다중화된 데이터는 필연적으로 동기화 작업이 필요해짐
- 정족수 합의(Quorum Consensus) 프로토콜을 사용하면 읽기/쓰기 연산 모두에 일관성 보장 가능
  - 적절한 W(쓰기 연산 정족수), R(읽기 연산 정족수), N(사본 개수) 값들을 설정해서 응답 지연과 데이터 일관성 사이에 타협점을 찾아야 함
  - W, R의 값이 작으면 빠른 응답 속도, 크면 느린 응답 속도
  - W == N, R == 1: 빠른 읽기 연산 최적화
  - W == 1, R == N: 빠른 쓰기 연산 최적화
  - W + R > N: 강한 일관성 보장
  - 보통 N = 3, W == R == 2
  - 중재자(coordinator): 클라이언트와 노드 사이에서 proxy 역할을 수행하며, 각 서버들의 ACK 응답을 받고 정족수를 확인

**결과적 일관성 보장하기**

- 결과적 일관성: 약한 일관성의 한 형태로, 갱신 결과가 결국에는 모든 사본에 동기화되는 모델
- 쓰기 연산을 병렬로 실행할 때 발생하는 동기화 문제를 클라이언트가 해결해야 함
- 일관성 불일치 해결 방법
  - **버저닝(versioning)**
    - 데이터가 변경될 때마다 해당 데이터에 대한 새 버전 생성
    - 각 데이터는 변경 불가능(immutable)
    - 서로 다른 서버들이 데이터를 수정했을 때의 충돌을 자동으로 해소할 수 없다는 문제가 존재
  - **벡터 시계(vector clock)**
    - `[서버, 버전]`의 순서쌍을 저장해두는 방식
    - 충돌하는 버전 간의 시간 순서를 쉽게 판단 가능
    - 클라이언트 측에 충돌 감지 및 해소 로직이 필요하며, 순서쌍 데이터를 관리하게 위한 공간도 필요함

### 장애 감지

- 가장 쉬운 방법은 멀티캐스팅 채널 구축, 하지만 서버가 많아질수록 비효율적
- **gossip protocol**
  - 각 노드는 `membership list` 저장
  - `membership list`는 `member id`, `heartbeat counter` 쌍의 목록 저장
  - 각 노드는 주기적으로 자신의 `heartbeat counter++`
  - 각 노드는 무작위 노드들에게 주기적으로 자신의 `heartbeat counter` 목록 전송
  - `heartbeat counter` 목록을 전달 받은 노드는 `membership list` 최신화
  - 만약 특정 노드의 `heartbeat counter`가 지정한 시간 동안 갱신되지 않으면 offline 상태로 간주
- **sloppy quorum**
  - 가용성 확보를 위해 정족수를 줄이는 방식 (느슨한 정족수)
  - 장애 상태의 서버는 무시하고 가용 가능한 W개의 쓰기 서버와 R개의 읽기 서버만 활용
- **hinted handoff**
  - 장애 서버가 생기면 장애 서버로 가는 요청을 다른 가용 서버가 임시로 처리하면서 가용성을 확보하는 방식
  - 장애 서버 복구 시 임시 처리 내용을 일괄 반영해서 데이터 일관성 보존
  - 임시 처리 서버는 복구 시 일괄 처리 작업을 위해 힌트를 남겨둬야 함
- **anti-entropy protocol**
  - 노드의 영구 장애 상태를 처리하기 위한 방식
  - 사본 간 일관성이 망가진 상태를 탐지하고 전송 데이터의 양을 줄임
  - 내부적으로 Merkle 트리 활용
    - 자식 노드들의 해시 값 또는 해시 값 형태의 label로부터 부모 트리를 상향식으로 형성하는 방식
    - 대규모 자료구조의 내용들을 효과적이면서도 안전하게 검증 가능
    - 루트 노드의 해시 값이 일치하면 두 서버는 같은 데이터를 가졌다고 판별하며, 다른 경우에는 자식 노드들의 해시 값을 비교 및 탐색하며 다른 값을 가진 버킷 대상으로만 동기화 작업 진행
    - 동기화 대상 데이터 양은 두 서버 간 데이터 총량에 비해서 작아지므로 효율적인 탐색 및 동기화가 가능해짐
    - 하지만 실제 시스템의 경우 버킷 하나의 크기가 꽤 크다는 점을 염두에 둘 것
