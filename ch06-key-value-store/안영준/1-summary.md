# 6장 키-값 저장소 설계

### 키-값 저장소가 무엇인가?

비관계형(NoSQL) 데이터베이스의 한 종류. 고유한 키와 값으로 데이터를 저장.

| 키 | 값 |
|:-|:-:|
|user_id_123|{name: "홍길동", age: 30}|
|session_abc|"active"|

- 키는 짧을수록 성능상 유리 (메모리 효율, 해시 계산 속도)
- 값은 문자열, JSON, 이미지 등 다양한 형태 가능
- 예: DynamoDB, Redis, Memcached

### 왜 분산 키-값 저장소가 필요한가?

단일 서버 한계: 저장 공간 제한, 트래픽 한계, 단일 장애점

**CAP 정리**

분산 시스템에서 세 가지 중 **최대 2가지만** 동시 만족 가능:

**C (Consistency)** - 모든 노드가 같은 시간에 같은 데이터 반환
**A (Availability)** - 일부 노드 장애 시에도 항상 응답
**P (Partition Tolerance)** - 네트워크 분할 시에도 동작 (필수)

| 조합 | 선택 | 특징 | 예시 |
|:-:|:-:|:-|:-|
| **CP** | 가용성 희생 | 일관성 보장, 장애 시 오류 | 은행, 결제 |
| **AP** | 일관성 희생 | 항상 응답, 오래된 데이터 가능 | SNS, 조회수 |
| ~~CA~~ | ~~불가능~~ | 네트워크 분할은 막을 수 없음 | - |

### 분산 키-값 저장소 설계 전략

**AP(가용성+파티션 감내)** 시스템 설계 가정.

#### 1. 데이터 파티션 - "어떻게 데이터를 분산?"

**문제:** 대용량 데이터를 여러 서버에 분산, 서버 추가/제거 시 재배치 최소화

**해결책: 안정 해시**
- 서버 추가/제거 시 평균 K/N 개의 키만 재배치
- 가상 노드로 데이터 균등 분산

#### 2. 데이터 다중화 - "가용성 보장?"

**문제:** 서버 1대 장애 시 데이터 손실

**해결책: 복제 (N개)**
- 시계 방향으로 N개 서버에 복제 (보통 N=3)

```
K1 → S1, S2, S3에 저장
S1 장애 → S2, S3에서 제공
```

**주의:** 가상 노드 사용 시 서로 다른 물리 서버 선택

#### 3. 일관성 vs 성능 - "균형?"

**문제:** 복제된 데이터 동기화, AP지만 일관성도 필요

**해결책: 정족수 합의 (Quorum)**

몇 개 노드에서 응답받을지 조정해 일관성과 성능 균형.

- **N** = 복제본 개수
- **W** = 쓰기 성공 응답 수
- **R** = 읽기 성공 응답 수

| 설정 | 일관성 | 특징 | 예시 |
|:-|:-:|:-|:-|
| **W+R > N** | 강함 | 최신 데이터 보장 | 중요 데이터 |
| **W+R ≤ N** | 약함 | 높은 성능 | 조회수, 추천 |

**예시 (N=3, W=2, R=2):**
```
쓰기: 2/3 노드 성공 → 완료
읽기: 2/3 노드에서 읽기
→ 최소 1개 겹침 → 최신 데이터 보장
```

#### 4. 버전 충돌 - "동시 쓰기?"

**문제:**
```
네트워크 분할:
S1 쓰기: name="김철수"
S2 쓰기: name="박영희"
→ 둘 다 최신!
```

**해결책: 벡터 시계**

[서버, 버전]으로 인과관계 추적.

```
초기: D([S1, 1])
S1 수정: D([S1, 2])
S2 수정: D([S1, 2], [S2, 1])

충돌:
- S2: D([S1, 2], [S2, 1])
- S3: D([S1, 2], [S3, 1])
→ 둘 다 클라이언트에 전달
→ 클라이언트가 병합 (쇼핑카트 합치기 등)
```

#### 5. 장애 대응 - "서버 죽으면?"

**장애 감지: 가십 프로토콜**

노드끼리 주기적으로 박동(heartbeat) 정보 교환.

```
S1 → S3: "내 카운터 10, S2 카운터 5"
S3 → S4: "내 카운터 8, S1 카운터 10, S2 카운터 5"
...
S2 카운터 증가 없음 → S2 장애 판단
```

**일시적 장애: 힌트 핸드오프**

```
정상: K1 → S1, S2, S3
S2 장애 → K1 → S1, S3, S4(임시)
         → S4는 "S2 것" 힌트 보관
S2 복구 → S4가 S2에 전달 후 삭제
```

가용성 유지 + 복제본 개수(N) 보장.

**영구적 불일치: 머클 트리**

```
    Root Hash
     /      \
  H(AB)    H(CD)
  /  \      /  \
H(A) H(B) H(C) H(D)

루트 비교 → 다르면 자식 비교 → 차이만 동기화
O(log N)으로 불일치 발견
```


### 전체 흐름

AP 시스템 설계 흐름:

```
1. 데이터 분산 (안정 해시) → 고르게 분산
2. 데이터 복제 (N개) → 가용성 보장
3. 일관성 조절 (W, R) → W+R>N 강함, ≤N 약함
4. 버전 충돌 (벡터 시계) → 동시 쓰기 병합
5. 장애 대응 → 가십(감지), 힌트(일시적), 머클(영구)
```

| 문제 | 해결책 | 핵심 |
|:-|:-|:-|
| 데이터 분산? | 안정 해시 | K/N만 재배치 |
| 가용성? | N개 복제 | 시계방향 N개 |
| 일관성 vs 성능? | 정족수 W,R | W+R>N 강함 |
| 동시 쓰기? | 벡터 시계 | 충돌 병합 |
| 장애 감지? | 가십 | 박동 교환 |
| 일시적 장애? | 힌트 핸드오프 | 임시 저장 |
| 영구 불일치? | 머클 트리 | O(log N) |