## 설계 요구사항

- 핵심 기능 2개
  - 피드 발행: 사용자가 스토리를 포스팅하면 저장 후 친구들에게 피드 전송
  - 뉴스 피드 생성: 모든 친구의 포스팅을 시간 역순으로 조합
- 사용자당 최대 5,000명의 친구
- 매일 천만 명이 방문 (10milion DAU)

## 설계 및 구현

### 피드 발행

- 사용자: POST 요청
- 로드밸런서: 트래픽을 웹 서버들로 분산
- 웹 서버: 요청을 내부 서비스로 중계
- 포스팅 저장 서비스: 새 포스팅을 DB 및 캐시에 저장
- 포스트 전송 서비스: 새 포스팅을 친구의 뉴스 피드에 푸시
- 알림 서비스: 친구들에게 새 포스팅이 올라왔음을 알림

### 뉴스 피드 생성

- 사용자: GET 요청
- 로드밸런서: 트래픽을 웹 서버들로 분산
- 웹 서버: 요청을 내부 뉴스 피드 서비스와 함께 처리
- 뉴스 피드 서비스: 캐시로부터 뉴스 피드를 가져옴

### fanout 방식

**fanout-on-write**

- 쓰기 시점에 fanout (= push model)
- 포스팅 완료 시 바로 사용자 캐시에 해당 포스팅 기록
- 장점
  - 뉴스 피드 실시간 갱신
  - 피드는 친구 목록의 사용자들에게 즉시 전송
  - 뉴스 피드를 읽어들이는 시간 단축
- 단점
  - 모든 친구의 뉴스 피드 갱신에 오랜 시간 소요
  - 서비스를 자주 사용하지 않는 사용자의 피드까지 갱신하므로 자원 낭비

**fanout-on-read**

- 읽기 시점에 fanout (= pull model)
- 사용자가 페이지를 로딩하는 시점에 새로운 포스트를 가져옴 (on-demand)
- 장점
  - 비활성화 유저의 피드까지 갱신하지 않음
- 단점
  - 뉴스 피드를 읽는 시간 증가

**hybrid fanout**

- 대부분의 사용자 대상으로 push model 적용
- 친구 및 팔로워가 많은 사용자에게는 pull model 적용

포스팅 업로드 시점에서 fanout 동작 순서

1. Graph DB로부터 친구 ID 목록 조회
2. 사용자 정보 캐시로부터 친구들 정보 조회
3. mute 설정 등에 따라 친구들 필터링
4. 친구 목록 및 새 포스팅의 ID를 MQ에 삽입
5. fanout 작업 서버는 MQ로부터 친구 목록 및 새 포스팅의 ID를 꺼내고, 뉴스 피드 캐시로 삽입

### 피드 읽기 흐름

1. 사용자의 GET 요청 → 로드밸런서 → 웹 서버 → 뉴스 피드 서비스 호출
2. 뉴스 피드 서비스는 뉴스 피드 캐시로부터 포스팅 ID 목록 조회
3. 사용자 이름, 사용자 사진, 포스팅 콘텐츠, 이미지 등을 사용자 캐시 및 포스팅 캐시로부터 가져와 완전한 뉴스 피드 생성
4. 생성된 뉴스 피드를 JSON 형태로 클라이언트에게 반환

### 캐시 구조

- 뉴스 피드: 피드 ID 저장
- 콘텐츠: 포스팅 데이터를 인기 콘텐츠 / 일반 콘텐츠 구분해서 저장
- 소셜 그래프: 사용자 간 관계 정보 저장
- Action: 좋아요, 댓글 등의 행위 정보 저장
- Counter: 좋아요 수, 응답 수, 팔로워 수, 팔로잉 수 등의 정보 저장

## Learn More Things

- 웹에서 무상태로 운영하는 방법
- 여러 데이터 센터 지원 방법
- 핵심 메트릭 모니터링 방법
- 데이터베이스
  - SQL vs NoSQL
  - 다중화 방법
  - 샤딩 방법
