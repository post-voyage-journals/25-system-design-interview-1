## 설계 요구사항

- 1:1 및 그룹 채팅 지원
- DAU 5천만
- 그룹 채팅 최대 100명 참가 가능
- 메시지 길이 제한 10만자 이하
- 응답지연 낮게
- 사용자 접속상태 표시 기능
- 푸시 알림 기능

## 설계 및 구현

### 메시지 수신 시나리오

**polling**

- 클라이언트가 주기적으로 서버에 요청을 보내서 메시지 확인
- 메시지가 없는 경우 서버 자원이 낭비됨

**long polling**

- 새 메시지 발견 혹은 타임아웃 될 때까지 연결 유지
- 송신 클라이언트와 수신 클라이언트의 같은 채팅 서버 연결을 보장할 수 없음
- 서버 입장에서 클라이언트가 연결 해제했는지 여부를 알 수 있는 방법이 없음
- 여전히 서버 자원 사용 측면에서 비효율적

**WebSocket**

- 서버가 클라이언트에게 비동기 메시지를 보낼 때 가장 널리 사용되는 기술
- 웹소켓 연결은 클라이언트가 시작
- 한번 맺어진 연결은 항구적이며 양방향
- 처음에는 HTTP 프로토콜 연결을 맺고, handshake 절차를 거쳐 웹소켓 연결로 업그레이드

⇒ 양방향이므로 메시지 송신 시나리오도 웹소켓 연결로 통일 가능

### 핵심 컴포넌트

**웹소켓 서버**

- 채팅 서버: 클라이언트 간 메시지 중계
- 접속 상태 서버: 사용자 접속 여부 관리

**HTTP 서버**

- API 서버: 로그인, 회원가입, 프로필 변경 등 나머지 기능들 처리
- 알림 서버: 푸시 알림 전송

**DB**

- 키-값 저장소: 채팅 이력 보관, 사용자가 이전 채팅 이력을 볼 수 있게 해줌
- RDBMS: 사용자 프로필, 친구 목록, 채팅방 정보 등 보관

**서비스 탐색**

- 클라이언트에게 가장 적합한 채팅 서버 추천 기능
- 클라이언트의 위치, 서버 상태 및 용량 등을 기반으로 탐색
- Apache Zookeeper 등의 오픈 소스 솔루션을 주로 사용함

### 1:1 메시지 흐름

1. 사용자 A가 채팅 서버 1로 메시지 전송
2. 채팅 서버 1은 ID 생성기를 사용해 메시지 ID 생성
3. 채팅 서버 1은 메시지를 메시지 동기화 큐로 전송
4. 메시지는 키-값 저장소에 보관
5. 사용자 B가 접속 중인 경우 채팅 서버 2로 전송 / 사용자 B가 접속 중이지 않은 경우 알림 서버로 전송
6. 채팅 서버 2는 메시지를 사용자 B에게 전송 (웹소켓 연결)

### 그룹 메시지

- 각 사용자는 메시지 수신함 개념의 메시지 동기화 큐를 가짐
- 사용자의 메시지 확인은 본인의 큐만 확인하면 되므로 동기화 작업이 단순해짐
- 사용자는 여러 사용자로부터 오는 메시지를 하나의 동기화 큐에서 수신

### 여러 단말 사이 메시지 동기화

- 동일한 사용자의 단말들은 동일한 채팅 서버에 접속
- 각 단말은 `cur_max_message_id` 변수를 유지해서 해당 단말의 최신 메시지 ID 추적

### 사용자 접속 상태 표시

- 로그인 시 `last_active_at` 타임스탬프 갱신
- 로그아웃 시 오프라인 처리
- 클라이언트는 heartbeat event를 접속 상태 서버로 전송
  - 마지막 이벤트 수신 시간으로부터 지정된 시간 만큼 지났을 경우 오프라인 처리
- 사용자들은 친구 목록 전체에 대해 pub-sub 모델 유지
  - 사용자 A의 접속 상태 변경 시 구독하고 있던 모든 친구들은 오프라인 상태를 전달받음
  - 하지만 그룹 크기가 커질 때는 비용 및 시간이 많이 소모되므로 상태 변화 변경을 느슨하게 해주는 방안도 고려해야 함

## 추가 고려사항들

- 사진이나 비디오 등의 미디어 지원 방법
  - 압축 방법, 저장소, 썸네일 생성 방법 등을 논의해볼 수 있을 것
- 종단 간 암호화
- 캐시
  - 클라이언트가 이미 읽은 메시지를 캐싱
- 로딩 속도 개선
  - 지역적 분산
- 에러 핸들링
  - 채팅 서버 오류
  - 메시지 재전송
